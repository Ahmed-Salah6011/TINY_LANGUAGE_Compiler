# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'com.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os
from PyQt5 import QtCore, QtGui, QtWidgets
from tkinter import filedialog
import re
import grammar as gr
import treescanner as src
from tkinter import messagebox

class Ui_MainWindow(object):
    def __init__(self):
            self.tokens=list()
            self.path=os.path.dirname(os.path.realpath(__file__))
            self.row=0
            self.Error=0
            self.good_flag=0

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1007, 728)
        MainWindow.setStyleSheet("background:#ecdfec    ;\n"
"border-radius:12px;")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.btn_add_text = QtWidgets.QPushButton(self.centralwidget)
        self.btn_add_text.setGeometry(QtCore.QRect(40, 540, 281, 81))
        self.btn_add_text.setStyleSheet("font: 20pt \\\"MV Boli\\\";\n"
"background:purple;\n"
"color:white;\n"
"border-radius:12px;")
        self.btn_add_text.setObjectName("btn_add_text")
        self.btn_scan = QtWidgets.QPushButton(self.centralwidget)
        self.btn_scan.setGeometry(QtCore.QRect(550, 560, 171, 51))
        self.btn_scan.setStyleSheet("font: 20pt \\\"MV Boli\\\";\n"
"background:purple;\n"
"color:white;\n"
"border-radius:12px;")
        self.btn_scan.setObjectName("btn_scan")
        self.btn_parse = QtWidgets.QPushButton(self.centralwidget)
        self.btn_parse.setGeometry(QtCore.QRect(770, 560, 171, 51))
        self.btn_parse.setStyleSheet("font: 20pt \\\"MV Boli\\\";\n"
"background:purple;\n"
"color:white;\n"
"border-radius:12px;")
        self.btn_parse.setObjectName("btn_parse")
        self.lbl_inp = QtWidgets.QLabel(self.centralwidget)
        self.lbl_inp.setGeometry(QtCore.QRect(50, 60, 241, 41))
        self.lbl_inp.setStyleSheet("font: 25pt \\\"MV Boli\\\";\n"
"color:black;\n"
"")
        self.lbl_inp.setObjectName("lbl_inp")
        self.lbl_out = QtWidgets.QLabel(self.centralwidget)
        self.lbl_out.setGeometry(QtCore.QRect(560, 60, 311, 41))
        self.lbl_out.setStyleSheet("font: 24pt \\\"MV Boli\\\";\n"
"color:black;\n"
"")
        self.lbl_out.setObjectName("lbl_out")
        self.txt_inp = QtWidgets.QTextEdit(self.centralwidget)
        self.txt_inp.setGeometry(QtCore.QRect(40, 120, 471, 401))
        self.txt_inp.setStyleSheet("font: 15pt;\n""background:white;")
        self.txt_inp.setObjectName("txt_inp")  
        self.txt_out = QtWidgets.QTextEdit(self.centralwidget)
        self.txt_out.setGeometry(QtCore.QRect(560, 120, 381, 401))
        self.txt_out.setStyleSheet("font: 15pt;\n""background:white;")
        self.txt_out.setObjectName("txt_out")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1007, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        ##########connections
        self.btn_add_text.clicked.connect(self.get_text)
        self.btn_scan.clicked.connect(self.scan_func)
        self.btn_parse.clicked.connect(self.pars_func)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Compiler"))
        self.btn_add_text.setText(_translate("MainWindow", "Add Text File"))
        self.btn_scan.setText(_translate("MainWindow", "Scan"))
        self.btn_parse.setText(_translate("MainWindow", "Parse"))
        self.lbl_inp.setText(_translate("MainWindow", "Input Code"))
        self.lbl_out.setText(_translate("MainWindow", "Output Tokens"))


    def get_text(self):
        try:
                file_path = filedialog.askopenfile().buffer.name
                # ind=file_path.rfind('/')
                # self.path=file_path[:ind]
                f = open(file_path,'r')
                self.lines=f.readlines()
                self.txt_inp.clear()
                for line in self.lines:
                        self.txt_inp.insertPlainText(line)
        except:
                messagebox.showerror("Error","Error in Text file")
        
    
    ##################################parse grammar functions
    def advance_input(self):
        self.row += 1
        return
  
    def match(self,str):

        if self.tokens[self.row][1] == str:
                self.advance_input()
                self.Error = 0
        else:
                self.Error = 1

    def mul_op(self):
        if self.tokens[self.row][0] == '*':
                self.match('MUL')

        else:
                self.match('DIV')

        # if self.Error == 0:
        #         print('mul operator found')

        if self.Error != 0:
                raise ValueError("can't match mull operator , error in mul operator")
                # print("can't match mull operator , error in mul operator")

    def add_op(self):
        if self.tokens[self.row][0] == '+':
                self.match('PLUS')

        else:
                self.match('MINUS')

        # if self.Error == 0:
        #         print('add_op found')

        # else:
        #         print("can't match add_op , error in add_op")
        if self.Error != 0:
                raise ValueError("can't match add_op , error in add_op")


    def comp_op(self):
        if self.tokens[self.row][0] == '<':
                self.match('LESSTHAN')
        else:
                self.match('EQUAL')

        # if self.Error == 0:
        #         print('Comparison operator found')

        # else:
        #         print("can't match comparison operator")
        if self.Error != 0:
                raise ValueError("can't match comparison operator")
    
    def stmt_seq(self):
        self.statement()
        while self.tokens[self.row][0] == ";":
                self.advance_input()
                if self.row > (len(self.tokens) - 1): ### to solve appearing error problem
                        break
                self.statement()
                if self.row > (len(self.tokens) - 1):
                        break

        # if self.Error == 0:
        #         print('Statement sequence found')


    def read_stmt(self):
        self.match("READ")
        self.match("IDENTIFIER")
        # if self.Error == 0:
        #         print("Read found")
        # else:
        #         print('ERROR found : Read statment is not correct')
        if self.Error != 0:
                raise ValueError("ERROR found : Read statment is not correct")
    
    def simple_exp(self):
        self.term()
        if self.row <= (len(self.tokens) - 1):
                if self.tokens[self.row][0] == '+' or self.tokens[self.row][0] == '-':
                        self.add_op()
                        self.term()

        # print('simple_exp found')

    def exp(self):
        self.simple_exp()

        if self.row <= (len(self.tokens) - 1):
                if self.tokens[self.row][0] == '<' or self.tokens[self.row][0] == '=':
                        self.comp_op()
                        self.simple_exp()

        # print('exp found')

    def factor(self):
        if self.tokens[self.row][0] == '(':
                self.match('OPENBRACKET')
                self.exp()
                self.match('CLOSEDBRACKET')

        elif self.tokens[self.row][1] == 'NUMBER':
                self.match('NUMBER')

                # if self.Error == 0:
                #         print('factor found as a number')

                # else:
                #         print('factor error , might be an error in matching number')
                if self.Error != 0:
                        raise ValueError("factor error , might be an error in matching number")

        elif self.tokens[self.row][1] == 'IDENTIFIER':
                self.match('IDENTIFIER')

                # if self.Error == 0:
                #         print('factor found as an identifier')

                # else:
                #         print('factor error , might be an error in matching identifier')
                if self.Error != 0:
                        raise ValueError("factor error , might be an error in matching identifier")

        else:
                self.Error = 1
                # print('factor error no such number , identifier or (exp)')
                raise ValueError("factor error no such number , identifier or (exp)")


    def term(self):
        self.factor()
        while self.tokens[self.row][0] == '*' or self.tokens[self.row][0] == '/':
                self.mul_op()
                self.factor()
                if self.row > (len(self.tokens) - 1):
                        break

        # print('term found')
    
    def if_stmt(self):
        self.match("IF")
        self.exp()
        self.match("THEN")
        self.stmt_seq()
        if self.tokens[self.row][0] == "else":
                self.stmt_seq()
        self.match("END")

        # if self.Error == 0:
        #         print("If statement found")
        # else:
        #         print("ERROR in if statement")
        if self.Error != 0:
                raise ValueError("ERROR in if statement")
        
    def assign_stmt(self):
        self.match('IDENTIFIER')
        self.match("ASSIGN")
        self.exp()

        # if self.Error == 0:
        #         print('assignment_statement found')

        # else:
        #         print("migth be an error in identifier")
        if self.Error != 0:
                raise ValueError("migth be an error in identifier")

    def statement(self):
        if self.tokens[self.row][1] == "IF":
                self.if_stmt()
        elif self.tokens[self.row][1] == "REPEAT":
                self.repeat_stmt()
        elif self.tokens[self.row][1] == "IDENTIFIER" and self.tokens[self.row+ 1][1] == "ASSIGN":
                self.assign_stmt()
        elif self.tokens[self.row][1] == "READ":
                self.read_stmt()
        elif self.tokens[self.row][1] == "WRITE":
                self.write_stmt()
        else:
                self.Error = 1

    def repeat_stmt(self):
        self.match("REPEAT")
        self.stmt_seq()
        self.match("UNTIL")
        self.exp()
        # if self.Error == 0:
        #         print("Repeat found")
        # else:
        #         print('ERROR found : Repeat statment is not correct')
        if self.Error != 0:
                raise ValueError("ERROR found : Repeat statment is not correct")

    def write_stmt(self):
        self.match('WRITE')
        self.exp()

        # if self.Error == 0:
        #         print('write statement found')

        # else:
        #         print('Error in write statement')
        if self.Error != 0:
                raise ValueError("Error in write statement")
    
    def program(self):
        self.stmt_seq()
        if self.Error == 0:
                self.good_flag=1
                messagebox.showinfo("Info","Grammar is Good")

        else:
                raise ValueError("Error in the Program")
                

    ##################################
    def pars_func(self):
        self.good_flag=0
        self.row=0
        self.Error=0
        try:
                self.program()
        except ValueError as e:
                messagebox.showerror("Error",e)
        
        except:
                messagebox.showerror("Error","Syntax Error!")

        if(self.good_flag==1):
                lines = self.txt_inp.toPlainText().lower().splitlines()
                gr.outputs = src.scanner(lines)
                gr.program()
                gr.generate_tree()

            
    #######################################
    def scan_func(self):
        ####empty the tokens list
        if len(self.tokens) !=0:
                self.tokens.clear()
        self.txt_out.clear()

        #####intialize the regex 
        assign_reg= r':='
        op_reg= r'\+|-|\*|/'
        com_reg= r'<|>'
        special_sym= r'\(|\)|;|='
        num_reg= r'\d{1,}(?:\.\d{1,})?'
        id_reg=r'(?:[a-z]|_)\w*'
        reserved_reg= r'if|then|else|end|repeat|until|read|write'
        comment_reg= r'{.*}'

        regex=[comment_reg,assign_reg,op_reg,com_reg,special_sym,num_reg,reserved_reg,id_reg]
        #regex_names=["comment","assign","operator","compare","symbol","number","reserved word","identifier"]
        regex_dict={"comment" : None ,
        "assign" :[(":=","ASSIGN")] ,
        "operator" : [("+","PLUS") , ("-","MINUS") , ("*","MUL") , ("/" , "DIV")],
        "compare" :[("<","LESSTHAN") , (">","GREATERTHAN")],
        "symbol" : [("(","OPENBRACKET") , (")","CLOSEDBRACKET") , (";","SEMICOLON") , ("=","EQUAL")],
        "number" : "NUMBER",
        "reserved word" : [("if","IF") , ("then","THEN") , ("else","ELSE") , ("end","END") , ("repeat","REPEAT") , ("until","UNTIL") , ("read","READ") , ("write","WRITE")],
        "identifier" : "IDENTIFIER",
        }

        total_reg= r'(%s|%s|%s|%s|%s|%s|%s|%s)' %(assign_reg,op_reg,com_reg,special_sym,comment_reg,num_reg,id_reg,reserved_reg)

        #####################
        
        ###append tokens for each line in the txt_inp

        final=list()
        text= self.txt_inp.toPlainText()
        text=text.lower().splitlines()
        for line in text:
                t=re.findall(total_reg,line)
                for token in t:
                        for reg,name in zip(regex,regex_dict.keys()):
                                j=re.findall(reg,token)
                                if len(j)==0: continue
                                if j[0] == token:
                                        if name == "identifier" or name == "number":
                                                final.append((token,regex_dict[name]))
                                        elif name == "comment" :
                                                break
                                        else :
                                                for x in regex_dict[name]:
                                                        if token == x[0] :
                                                                final.append((token,x[1])) 
                                        #final.append((token,name))
                                        break
                if len(final) != 0 :
                        self.tokens.append(list(final))
                final.clear()

        ############################
                
        ###print the output
        # print(self.tokens)
        ff= open(os.path.join(self.path,"out.txt") , 'w')
        for i in range(len(self.tokens)):
                self.txt_out.append("Line #{}".format(i+1))
                t_line = self.tokens[i]
                for t in t_line:
                        self.txt_out.append("{} , {}".format(t[0],t[1]))
                        ff.write("{} , {}\n".format(t[0],t[1]))
                self.txt_out.append("")
        

        ###making all in one list
        t= [tok for line in self.tokens for tok in line]
        self.tokens=list(t)
        # print(self.tokens)



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())